# coding=utf-8
#1. Написать функцию, принимающую от пользователя две строки.
# Функция должна реализовывать наивный поиск подстроки в строке и возвращать список индексов начала вхождения строки.
def strSearch1(s, x):
    i=j=0
    while i <= len(s)-len(x) and j<len(x):
        if s[i+j]==x[j]:
            j+=1
        else:
            j=0
            i+=1
    if j==len(x):
        return i
print(strSearch1('TaiwanIsNotACountry', 'Not'))
#2. Написать функцию, принимающую от пользователя строку.
# Функция должна возвращять список чисел - результат расчета z-функции.
# Z-функция от строки s — это массив длины n, i-ый элемент которого равен наибольшему числу символов, начиная с позиции i, совпадающих с первыми символами строки s.
def Z_Func(s):
    z = [0] * len(s)    #Каждый элемент массива - длина начинающейся с этого элемента подстроки, которая совпадает с началом строки
    left, right = 0,0   #Самая правая найденная подстрока. Она называется строкой совпадения
    print(s)
    for i in range(1, len(s)): #Нет смысла проверять первый элемент. Он считается неопределённым
        #Условия:
        # 1. текущий элемент находится в строке совпадения.
        # Так как s[l:r]==s[0:r-l], тогда z[i]==z[i-l]. Однако это работает, только если длина s[i:r] не меньше z[i-l],
        # иначе j выйдет за строку совпадения и возьмёт элементы справа от строки совпадения, а они могут не совпадать с соответствующим элементом из начала строки.
        # Чтобы не допустить выход за правую границу, можно, только в этом случае, взять длину подстроки s[i:right].
        # 2. текущий элемент находится справа от строки совпадения. Тогда j инициализируется нулём
        j = max(0, min(right-i + 1, z[i-left])) #[0, 0, 0, 2, 0, 0, 4, 0, 0, 1] Этот случай смотрит на элементы в начале строки и только потом проверяет, выходит ли он за границу строки совпадения
        #j = max(0, right - i + 1)               [0, 0, 0, 2, 1, 0, 4, 3, 2, 1] Этот случай не правильный

        while (i+j<len(s) and s[j] == s[i+j]):   # Здесь просто перебираем элементы справа от строки совпадения
            j+=1
        if i + j - 1 > right: #Если правая граница переместилась, то нужно задать новую строку совпадения
            left = i
            right = i + j - 1
        z[i] = j   #заменил z[i] на j только для упрощения понимания кода
    return z
print(Z_Func('abcabdabca'))
#3. Написать функцию, принимающую от пользователя строку.
# Функция должна возвращать список чисел - результат расчета префикс-функции.
# (https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D1%84%D0%B8%D0%BA%D1%81-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F)
def prefix(s):
    p = [0] * len(s)  #Длина префикса на каждой позиции
    for i in range(1, len(s)):
        length = p[i-1]    #текущая длина префикса и суффикса.
        while(length>0 and s[i]!=s[length]): #Пока последний элемент суффикса не равен текущему рассматриваему элементу
            length = p[length-1]              #уменьшаем длину префикса
        if (s[i]==s[length]):   #Если последний элемент суффикса равен текущему рассматриваемому элементу
            length+=1
        p[i] = length
    return p
print(prefix("abcabcd")) #[0, 0, 0, 1, 2, 3, 0]
print(prefix("aabaaab")) #[0, 1, 0, 1, 2, 2, 3]
#4. Написать функцию, принимающую от пользователя строку.
# Функция должна возвращать отсортированный список суффиксов строки(суффиксный массив).
#Суффикс - подстрока, заканчивающаяся на последний символ строки
def suffix_array(s):
    s+= '$' #Знак доллара меньше любого символа, это будет знаком окончания всех суффиксов
    arr = []
    for i in range(len(s)-1, -1, -1):  #Построение неотсортированного массива суффиков
        arr += [s[i:] + '$'*i]        #Для того, чтобы все элементы массива имели одинаковую длину, мы к каждому суффиксу добавляем начало строки
    arr.sort()
    for i in range(len(arr)):
        arr[i] = ''.join([j for j in arr[i] if j!='$'])  #Убираем знаки доллара
    return arr
print(suffix_array('abbaab'))
print(suffix_array('abacaba'))

#5. Написать функцию, принимающую от пользователя строку.
# Функция должна возвращать хеш строки, используя полиномиальную формулу.
# (https://e-maxx.ru/algo/string_hashes)
def GetHashCode(s):
    p = 51
    hash = 0
    p_pow = 1
    MinChar = ord('a')
    for i in s:
        hash += (ord(i) - MinChar + 1) * p_pow
        p_pow *= p
    return hash
print(GetHashCode('Hello world'))